### ğŸ§© **Symfony Contracts BileÅŸeni**

Symfony **Contracts** bileÅŸeni, Symfony Ã§ekirdek bileÅŸenlerinden **soyutlamalarÄ± (abstractions)** ayÄ±rarak tek baÅŸÄ±na kullanÄ±labilir hale getirir.
Bu sayede, Symfony bileÅŸenlerinin kanÄ±tlanmÄ±ÅŸ (battle-tested) mantÄ±klarÄ±nÄ± yeniden kullanmak ve **gevÅŸek baÄŸlÄ± (loosely coupled)** uygulamalar geliÅŸtirmek mÃ¼mkÃ¼n olur.

---

### âš™ï¸ **Kurulum (Installation)**

Contracts bileÅŸenleri ayrÄ± ayrÄ± paketler halinde daÄŸÄ±tÄ±lÄ±r.
Projeniz iÃ§in yalnÄ±zca ihtiyacÄ±nÄ±z olanlarÄ± yÃ¼kleyebilirsiniz:

```bash
composer require symfony/cache-contracts
composer require symfony/event-dispatcher-contracts
composer require symfony/deprecation-contracts
composer require symfony/http-client-contracts
composer require symfony/service-contracts
composer require symfony/translation-contracts
```

> EÄŸer Symfony dÄ±ÅŸÄ±nda baÄŸÄ±msÄ±z bir PHP projesinde kullanÄ±yorsanÄ±z,
> `vendor/autoload.php` dosyasÄ±nÄ± **require** ederek Composerâ€™Ä±n otomatik yÃ¼kleme (autoloading) sistemini etkinleÅŸtirmelisiniz.

---

### ğŸ§  **KullanÄ±m (Usage)**

Contracts bileÅŸeni, **gevÅŸek baÄŸÄ±mlÄ±lÄ±k (loose coupling)** ve **birlikte Ã§alÄ±ÅŸabilirlik (interoperability)** saÄŸlamak iÃ§in tasarlanmÄ±ÅŸtÄ±r.

* Bu paketteki **arayÃ¼zleri (interfaces)** type-hint olarak kullanarak,
  farklÄ± bileÅŸenlerin veya kÃ¼tÃ¼phanelerin implementasyonlarÄ±nÄ± rahatÃ§a deÄŸiÅŸtirebilirsiniz.
* Yani, `LoggerInterface` ya da `CacheInterface` gibi bir contract kullandÄ±ÄŸÄ±nÄ±zda,
  Symfony bileÅŸenini veya tamamen baÅŸka bir PHP paketini kullanabilirsiniz.

BazÄ± arayÃ¼zler, **autowiring** ile doÄŸrudan servislerinize enjekte edilebilir:
Symfony, bu arayÃ¼zleri otomatik olarak doÄŸru implementasyonlarla eÅŸleÅŸtirir.

BazÄ± arayÃ¼zler ise â€œ**etiketleyici (marker interface)**â€ olarak kullanÄ±lÄ±r.
Bu tÃ¼r arayÃ¼zler, autoconfiguration veya manuel **service tagging** iÅŸlemlerinde
Ã¶zel davranÄ±ÅŸlarÄ± etkinleÅŸtirmek iÃ§in kullanÄ±lÄ±r.

---

### ğŸ§© **TasarÄ±m Ä°lkeleri (Design Principles)**

Contracts bileÅŸeni ÅŸu prensiplerle geliÅŸtirilmiÅŸtir:

1. **KapsamÄ±na gÃ¶re bÃ¶lÃ¼nmÃ¼ÅŸtÃ¼r**
   Her domain (alan) kendi alt namespaceâ€™i altÄ±nda bulunur.
   Ã–rneÄŸin: `Symfony\Contracts\EventDispatcher\Event` veya `Symfony\Contracts\Service\ServiceSubscriberInterface`.

2. **KÃ¼Ã§Ã¼k ve tutarlÄ±** bir yapÄ±ya sahiptir.
   YalnÄ±zca gerekli PHP arayÃ¼zleri, traitâ€™ler, dokÃ¼mantasyon aÃ§Ä±klamalarÄ± ve test referanslarÄ± bulunur.

3. **KanÄ±tlanmÄ±ÅŸ (proven)** implementasyonu olmayan hiÃ§bir contract eklenmez.
   Her arayÃ¼zÃ¼n en az bir Ã§alÄ±ÅŸan Ã¶rneÄŸi Symfony bileÅŸenlerinde bulunmalÄ±dÄ±r.

4. Symfony bileÅŸenleriyle **geri uyumlu (backward compatible)** olmalÄ±dÄ±r.

---

### ğŸ§¾ **Composer ile Contract Bildirimi**

Bir paket belirli bir contractâ€™Ä± uyguluyorsa, bunu `composer.json` dosyasÄ±ndaki
`provide` bÃ¶lÃ¼mÃ¼nde belirtmelidir:

```json
{
    "provide": {
        "symfony/cache-implementation": "3.0"
    }
}
```

Bu, paketin `symfony/cache-contracts` arayÃ¼zlerini implemente ettiÄŸini gÃ¶sterir.
Bu sayede Composer, baÄŸÄ±mlÄ±lÄ±klarÄ± doÄŸru ÅŸekilde eÅŸleÅŸtirir.

---

### â“ **SÄ±k Sorulan Soru: PHP-FIG PSRâ€™lardan FarkÄ± Ne?**

Symfony Contracts, **PHP-FIG PSR standartlarÄ±nÄ± tamamlayÄ±cÄ±** bir yapÄ±dÄ±r.
Uygun olduÄŸu durumlarda PSR arayÃ¼zlerini temel alÄ±r veya onlarÄ±n Ã¼zerine inÅŸa edilir.

Fakat aralarÄ±ndaki farklar ÅŸunlardÄ±r:

| Ã–zellik  | PSR (PHP-FIG)                                     | Symfony Contracts                                             |
| -------- | ------------------------------------------------- | ------------------------------------------------------------- |
| **AmaÃ§** | PHP topluluÄŸu genelinde ortak standart oluÅŸturmak | Symfony bileÅŸenlerinin ihtiyaÃ§ duyduÄŸu soyutlamalarÄ± saÄŸlamak |
| **YapÄ±** | PSR standardizasyon sÃ¼reciyle belirlenir          | Symfony bileÅŸenlerinden tÃ¼retilmiÅŸ pratik arayÃ¼zler iÃ§erir    |
| **Odak** | Genel PHP ekosistemi                              | Symfonyâ€™nin iÃ§ bileÅŸenleriyle doÄŸrudan uyum                   |

Symfony Contracts, PSR standartlarÄ±yla **uyumlu**,
ama Symfony uygulamalarÄ±na **Ã¶zgÃ¼ semantik soyutlamalar** iÃ§erir.

---

### ğŸ§­ **Ã–zet**

| BaÅŸlÄ±k               | AÃ§Ä±klama                                                                                     |
| -------------------- | -------------------------------------------------------------------------------------------- |
| **AmaÃ§**             | Symfony bileÅŸenlerinden tÃ¼retilmiÅŸ soyutlamalarÄ± baÄŸÄ±msÄ±z olarak sunmak                      |
| **FaydasÄ±**          | GevÅŸek baÄŸlÄ±lÄ±k, test edilebilirlik, yeniden kullanÄ±labilirlik                               |
| **Kurulum**          | `composer require symfony/*-contracts`                                                       |
| **KullanÄ±m**         | ArayÃ¼zleri type-hint olarak kullanarak farklÄ± implementasyonlarÄ± kolayca deÄŸiÅŸtirebilirsiniz |
| **TasarÄ±m Ä°lkeleri** | KÃ¼Ã§Ã¼k, modÃ¼ler, tutarlÄ±, geri uyumlu                                                         |
| **PSR FarkÄ±**        | PSRâ€™larÄ± tamamlayÄ±cÄ±, Symfony odaklÄ± soyutlama yapÄ±sÄ±                                        |

---

### ğŸ’¡ Ã–rnek KullanÄ±m

```php
use Symfony\Contracts\Service\ServiceSubscriberInterface;
use Symfony\Contracts\Service\ServiceSubscriberTrait;

class MyService implements ServiceSubscriberInterface
{
    use ServiceSubscriberTrait;

    public function __construct(private \Psr\Log\LoggerInterface $logger) {}

    public static function getSubscribedServices(): array
    {
        return [
            'logger' => \Psr\Log\LoggerInterface::class,
        ];
    }

    public function doSomething(): void
    {
        $this->logger->info('Contracts are working!');
    }
}
```

Bu Ã¶rnekte, `ServiceSubscriberInterface` bir **contract**tÄ±r.
SÄ±nÄ±f, Symfonyâ€™nin **service container** sistemiyle gevÅŸek baÄŸlÄ± bir ÅŸekilde entegre olur.

---

### ğŸ”š SonuÃ§

Symfony Contracts, **baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ±zÄ± soyutlamanÄ±n en iyi yolu**dur.

* BileÅŸenler arasÄ± **baÄŸÄ±msÄ±zlÄ±ÄŸÄ±** artÄ±rÄ±r,
* **test edilebilirliÄŸi** kolaylaÅŸtÄ±rÄ±r,
* PSR standartlarÄ±yla **uyumlu** ama Symfonyâ€™ye Ã¶zgÃ¼ semantik saÄŸlar.

KÄ±saca:

> Contracts, Symfonyâ€™nin kalbinde yatan â€œtemiz mimariâ€ felsefesini PHP ekosistemine taÅŸÄ±r.
